
xdp_adjust_tail_kern.o:	file format ELF64-BPF

Disassembly of section xdp_icmp:
_xdp_icmp:
; {
       0:	bf 16 00 00 00 00 00 00 	r6 = r1
       1:	b7 07 00 00 01 00 00 00 	r7 = 1
; void *data_end = (void *)(long)xdp->data_end;
       2:	61 61 04 00 00 00 00 00 	r1 = *(u32 *)(r6 + 4)
; void *data = (void *)(long)xdp->data;
       3:	61 62 00 00 00 00 00 00 	r2 = *(u32 *)(r6 + 0)
; if (eth + 1 > data_end)
       4:	bf 23 00 00 00 00 00 00 	r3 = r2
       5:	07 03 00 00 0e 00 00 00 	r3 += 14
       6:	2d 13 6c 00 00 00 00 00 	if r3 > r1 goto +108 <LBB0_9>
; h_proto = eth->h_proto;
       7:	71 23 0c 00 00 00 00 00 	r3 = *(u8 *)(r2 + 12)
       8:	71 24 0d 00 00 00 00 00 	r4 = *(u8 *)(r2 + 13)
       9:	67 04 00 00 08 00 00 00 	r4 <<= 8
      10:	4f 34 00 00 00 00 00 00 	r4 |= r3
      11:	b7 07 00 00 02 00 00 00 	r7 = 2
; if (h_proto == htons(ETH_P_IP))
      12:	55 04 66 00 08 00 00 00 	if r4 != 8 goto +102 <LBB0_9>
; int pckt_size = data_end - data;
      13:	1f 21 00 00 00 00 00 00 	r1 -= r2
      14:	67 01 00 00 20 00 00 00 	r1 <<= 32
      15:	c7 01 00 00 20 00 00 00 	r1 s>>= 32
; if (pckt_size > MAX_PCKT_SIZE) {
      16:	b7 02 00 00 59 02 00 00 	r2 = 601
      17:	6d 12 61 00 00 00 00 00 	if r2 s> r1 goto +97 <LBB0_9>
; if (bpf_xdp_adjust_tail(xdp, 0 - offset))
      18:	b7 02 00 00 62 00 00 00 	r2 = 98
      19:	1f 12 00 00 00 00 00 00 	r2 -= r1
      20:	bf 61 00 00 00 00 00 00 	r1 = r6
      21:	85 00 00 00 41 00 00 00 	call 65
      22:	67 00 00 00 20 00 00 00 	r0 <<= 32
      23:	77 00 00 00 20 00 00 00 	r0 >>= 32
      24:	55 00 5a 00 00 00 00 00 	if r0 != 0 goto +90 <LBB0_9>
; if (bpf_xdp_adjust_head(xdp, 0 - headroom))
      25:	bf 61 00 00 00 00 00 00 	r1 = r6
      26:	18 02 00 00 e4 ff ff ff 00 00 00 00 00 00 00 00 	r2 = 4294967268 ll
      28:	85 00 00 00 2c 00 00 00 	call 44
      29:	67 00 00 00 20 00 00 00 	r0 <<= 32
      30:	77 00 00 00 20 00 00 00 	r0 >>= 32
      31:	b7 07 00 00 01 00 00 00 	r7 = 1
      32:	55 00 52 00 00 00 00 00 	if r0 != 0 goto +82 <LBB0_9>
; void *data_end = (void *)(long)xdp->data_end;
      33:	61 61 04 00 00 00 00 00 	r1 = *(u32 *)(r6 + 4)
; void *data = (void *)(long)xdp->data;
      34:	61 66 00 00 00 00 00 00 	r6 = *(u32 *)(r6 + 0)
; if (data + (ICMP_TOOBIG_SIZE + headroom) > data_end)
      35:	bf 62 00 00 00 00 00 00 	r2 = r6
      36:	07 02 00 00 7e 00 00 00 	r2 += 126
      37:	b7 07 00 00 01 00 00 00 	r7 = 1
      38:	2d 12 4c 00 00 00 00 00 	if r2 > r1 goto +76 <LBB0_9>
; memcpy(eth->h_source, orig_eth->h_dest, ETH_ALEN);
      39:	71 61 21 00 00 00 00 00 	r1 = *(u8 *)(r6 + 33)
      40:	73 16 0b 00 00 00 00 00 	*(u8 *)(r6 + 11) = r1
      41:	71 61 20 00 00 00 00 00 	r1 = *(u8 *)(r6 + 32)
      42:	73 16 0a 00 00 00 00 00 	*(u8 *)(r6 + 10) = r1
      43:	71 61 1f 00 00 00 00 00 	r1 = *(u8 *)(r6 + 31)
      44:	73 16 09 00 00 00 00 00 	*(u8 *)(r6 + 9) = r1
      45:	71 61 1e 00 00 00 00 00 	r1 = *(u8 *)(r6 + 30)
      46:	73 16 08 00 00 00 00 00 	*(u8 *)(r6 + 8) = r1
      47:	71 61 1d 00 00 00 00 00 	r1 = *(u8 *)(r6 + 29)
      48:	73 16 07 00 00 00 00 00 	*(u8 *)(r6 + 7) = r1
      49:	71 61 1c 00 00 00 00 00 	r1 = *(u8 *)(r6 + 28)
      50:	73 16 06 00 00 00 00 00 	*(u8 *)(r6 + 6) = r1
; memcpy(eth->h_dest, orig_eth->h_source, ETH_ALEN);
      51:	71 61 25 00 00 00 00 00 	r1 = *(u8 *)(r6 + 37)
      52:	73 16 03 00 00 00 00 00 	*(u8 *)(r6 + 3) = r1
      53:	71 61 24 00 00 00 00 00 	r1 = *(u8 *)(r6 + 36)
      54:	73 16 02 00 00 00 00 00 	*(u8 *)(r6 + 2) = r1
      55:	71 61 23 00 00 00 00 00 	r1 = *(u8 *)(r6 + 35)
      56:	73 16 01 00 00 00 00 00 	*(u8 *)(r6 + 1) = r1
      57:	71 61 22 00 00 00 00 00 	r1 = *(u8 *)(r6 + 34)
      58:	73 16 00 00 00 00 00 00 	*(u8 *)(r6 + 0) = r1
      59:	71 61 27 00 00 00 00 00 	r1 = *(u8 *)(r6 + 39)
      60:	73 16 05 00 00 00 00 00 	*(u8 *)(r6 + 5) = r1
      61:	71 61 26 00 00 00 00 00 	r1 = *(u8 *)(r6 + 38)
      62:	73 16 04 00 00 00 00 00 	*(u8 *)(r6 + 4) = r1
; eth->h_proto = orig_eth->h_proto;
      63:	71 61 29 00 00 00 00 00 	r1 = *(u8 *)(r6 + 41)
      64:	73 16 0d 00 00 00 00 00 	*(u8 *)(r6 + 13) = r1
      65:	71 61 28 00 00 00 00 00 	r1 = *(u8 *)(r6 + 40)
      66:	73 16 0c 00 00 00 00 00 	*(u8 *)(r6 + 12) = r1
; icmp_hdr->type = ICMP_DEST_UNREACH;
      67:	b7 01 00 00 03 04 00 00 	r1 = 1027
      68:	63 16 22 00 00 00 00 00 	*(u32 *)(r6 + 34) = r1
; icmp_hdr->un.frag.mtu = htons(MAX_PCKT_SIZE-sizeof(struct ethhdr));
      69:	b7 01 00 00 02 4a 00 00 	r1 = 18946
      70:	6b 16 28 00 00 00 00 00 	*(u16 *)(r6 + 40) = r1
; memcpy(eth->h_dest, orig_eth->h_source, ETH_ALEN);
      71:	bf 63 00 00 00 00 00 00 	r3 = r6
      72:	07 03 00 00 22 00 00 00 	r3 += 34
      73:	b7 07 00 00 00 00 00 00 	r7 = 0
; *csum = bpf_csum_diff(0, 0, data_start, data_size, *csum);
      74:	b7 01 00 00 00 00 00 00 	r1 = 0
      75:	b7 02 00 00 00 00 00 00 	r2 = 0
      76:	b7 04 00 00 5c 00 00 00 	r4 = 92
      77:	b7 05 00 00 00 00 00 00 	r5 = 0
      78:	85 00 00 00 1c 00 00 00 	call 28
; iph->ihl = 5;
      79:	b7 01 00 00 45 00 00 70 	r1 = 1879048261
      80:	63 16 0e 00 00 00 00 00 	*(u32 *)(r6 + 14) = r1
; iph->ttl = DEFAULT_TTL;
      81:	b7 01 00 00 40 01 00 00 	r1 = 320
      82:	63 16 16 00 00 00 00 00 	*(u32 *)(r6 + 22) = r1
; iph->daddr = orig_iph->saddr;
      83:	61 61 36 00 00 00 00 00 	r1 = *(u32 *)(r6 + 54)
      84:	63 16 1e 00 00 00 00 00 	*(u32 *)(r6 + 30) = r1
; iph->saddr = orig_iph->daddr;
      85:	61 61 3a 00 00 00 00 00 	r1 = *(u32 *)(r6 + 58)
      86:	63 16 1a 00 00 00 00 00 	*(u32 *)(r6 + 26) = r1
; return ~((csum & 0xffff) + (csum >> 16));
      87:	bf 01 00 00 00 00 00 00 	r1 = r0
      88:	77 01 00 00 10 00 00 00 	r1 >>= 16
      89:	0f 01 00 00 00 00 00 00 	r1 += r0
; icmp_hdr->checksum = csum;
      90:	a7 01 00 00 ff ff ff ff 	r1 ^= -1
      91:	6b 16 24 00 00 00 00 00 	*(u16 *)(r6 + 36) = r1
; iph = data + off;
      92:	bf 63 00 00 00 00 00 00 	r3 = r6
      93:	07 03 00 00 0e 00 00 00 	r3 += 14
; *csum = bpf_csum_diff(0, 0, data_start, data_size, *csum);
      94:	b7 01 00 00 00 00 00 00 	r1 = 0
      95:	b7 02 00 00 00 00 00 00 	r2 = 0
      96:	b7 04 00 00 14 00 00 00 	r4 = 20
      97:	b7 05 00 00 00 00 00 00 	r5 = 0
      98:	85 00 00 00 1c 00 00 00 	call 28
; return ~((csum & 0xffff) + (csum >> 16));
      99:	bf 01 00 00 00 00 00 00 	r1 = r0
     100:	77 01 00 00 10 00 00 00 	r1 >>= 16
     101:	0f 01 00 00 00 00 00 00 	r1 += r0
; iph->check = csum;
     102:	a7 01 00 00 ff ff ff ff 	r1 ^= -1
     103:	6b 16 18 00 00 00 00 00 	*(u16 *)(r6 + 24) = r1
; u64 key = 0;
     104:	7b 7a f8 ff 00 00 00 00 	*(u64 *)(r10 - 8) = r7
     105:	bf a2 00 00 00 00 00 00 	r2 = r10
; __u32 csum = 0;
     106:	07 02 00 00 f8 ff ff ff 	r2 += -8
; icmp_count = bpf_map_lookup_elem(&icmpcnt, &key);
     107:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 	r1 = 0 ll
     109:	85 00 00 00 01 00 00 00 	call 1
; if (icmp_count)
     110:	15 00 03 00 00 00 00 00 	if r0 == 0 goto +3 <LBB0_8>
; *icmp_count += 1;
     111:	79 01 00 00 00 00 00 00 	r1 = *(u64 *)(r0 + 0)
     112:	07 01 00 00 01 00 00 00 	r1 += 1
     113:	7b 10 00 00 00 00 00 00 	*(u64 *)(r0 + 0) = r1

LBB0_8:
     114:	b7 07 00 00 03 00 00 00 	r7 = 3

LBB0_9:
; }
     115:	bf 70 00 00 00 00 00 00 	r0 = r7
     116:	95 00 00 00 00 00 00 00 	exit
