
xdp_fwd_kern.o:	file format ELF64-BPF

Disassembly of section xdp_fwd:
xdp_fwd_prog:
; {
       0:	b7 00 00 00 01 00 00 00 	r0 = 1
; void *data_end = (void *)(long)ctx->data_end;
       1:	61 12 04 00 00 00 00 00 	r2 = *(u32 *)(r1 + 4)
; void *data = (void *)(long)ctx->data;
       2:	61 16 00 00 00 00 00 00 	r6 = *(u32 *)(r1 + 0)
; if (data + nh_off > data_end)
       3:	bf 67 00 00 00 00 00 00 	r7 = r6
       4:	07 07 00 00 0e 00 00 00 	r7 += 14
       5:	2d 27 8d 00 00 00 00 00 	if r7 > r2 goto +141 <LBB0_17>
       6:	b7 03 00 00 00 00 00 00 	r3 = 0
; __builtin_memset(&fib_params, 0, sizeof(fib_params));
       7:	7b 3a f8 ff 00 00 00 00 	*(u64 *)(r10 - 8) = r3
       8:	7b 3a f0 ff 00 00 00 00 	*(u64 *)(r10 - 16) = r3
       9:	7b 3a e8 ff 00 00 00 00 	*(u64 *)(r10 - 24) = r3
      10:	7b 3a e0 ff 00 00 00 00 	*(u64 *)(r10 - 32) = r3
      11:	7b 3a d8 ff 00 00 00 00 	*(u64 *)(r10 - 40) = r3
      12:	7b 3a d0 ff 00 00 00 00 	*(u64 *)(r10 - 48) = r3
      13:	7b 3a c8 ff 00 00 00 00 	*(u64 *)(r10 - 56) = r3
      14:	7b 3a c0 ff 00 00 00 00 	*(u64 *)(r10 - 64) = r3
; h_proto = eth->h_proto;
      15:	71 63 0c 00 00 00 00 00 	r3 = *(u8 *)(r6 + 12)
      16:	71 68 0d 00 00 00 00 00 	r8 = *(u8 *)(r6 + 13)
      17:	67 08 00 00 08 00 00 00 	r8 <<= 8
      18:	4f 38 00 00 00 00 00 00 	r8 |= r3
; if (h_proto == htons(ETH_P_IP)) {
      19:	55 08 18 00 08 00 00 00 	if r8 != 8 goto +24 <LBB0_5>
; if (iph + 1 > data_end)
      20:	bf 63 00 00 00 00 00 00 	r3 = r6
      21:	07 03 00 00 22 00 00 00 	r3 += 34
      22:	b7 00 00 00 01 00 00 00 	r0 = 1
      23:	2d 23 7b 00 00 00 00 00 	if r3 > r2 goto +123 <LBB0_17>
; if (iph->ttl <= 1)
      24:	71 62 16 00 00 00 00 00 	r2 = *(u8 *)(r6 + 22)
      25:	b7 00 00 00 02 00 00 00 	r0 = 2
      26:	2d 20 78 00 00 00 00 00 	if r0 > r2 goto +120 <LBB0_17>
      27:	b7 02 00 00 02 00 00 00 	r2 = 2
; fib_params.family	= AF_INET;
      28:	73 2a c0 ff 00 00 00 00 	*(u8 *)(r10 - 64) = r2
; fib_params.tos		= iph->tos;
      29:	71 62 0f 00 00 00 00 00 	r2 = *(u8 *)(r6 + 15)
      30:	73 2a cc ff 00 00 00 00 	*(u8 *)(r10 - 52) = r2
; fib_params.l4_protocol	= iph->protocol;
      31:	71 62 17 00 00 00 00 00 	r2 = *(u8 *)(r6 + 23)
      32:	73 2a c1 ff 00 00 00 00 	*(u8 *)(r10 - 63) = r2
; fib_params.sport	= 0;
      33:	b7 02 00 00 00 00 00 00 	r2 = 0
      34:	6b 2a c2 ff 00 00 00 00 	*(u16 *)(r10 - 62) = r2
; fib_params.dport	= 0;
      35:	6b 2a c4 ff 00 00 00 00 	*(u16 *)(r10 - 60) = r2
; fib_params.tot_len	= ntohs(iph->tot_len);
      36:	69 62 10 00 00 00 00 00 	r2 = *(u16 *)(r6 + 16)
      37:	dc 02 00 00 10 00 00 00 	r2 = be16 r2
      38:	6b 2a c6 ff 00 00 00 00 	*(u16 *)(r10 - 58) = r2
; fib_params.ipv4_src	= iph->saddr;
      39:	61 62 1a 00 00 00 00 00 	r2 = *(u32 *)(r6 + 26)
      40:	63 2a d0 ff 00 00 00 00 	*(u32 *)(r10 - 48) = r2
; fib_params.ipv4_dst	= iph->daddr;
      41:	61 62 1e 00 00 00 00 00 	r2 = *(u32 *)(r6 + 30)
      42:	63 2a e0 ff 00 00 00 00 	*(u32 *)(r10 - 32) = r2
      43:	05 00 2c 00 00 00 00 00 	goto +44 <LBB0_9>

LBB0_5:
      44:	b7 00 00 00 02 00 00 00 	r0 = 2
; } else if (h_proto == htons(ETH_P_IPV6)) {
      45:	55 08 65 00 86 dd 00 00 	if r8 != 56710 goto +101 <LBB0_17>
; if (ip6h + 1 > data_end)
      46:	bf 63 00 00 00 00 00 00 	r3 = r6
      47:	07 03 00 00 36 00 00 00 	r3 += 54
      48:	b7 00 00 00 01 00 00 00 	r0 = 1
      49:	2d 23 61 00 00 00 00 00 	if r3 > r2 goto +97 <LBB0_17>
; if (ip6h->hop_limit <= 1)
      50:	71 62 15 00 00 00 00 00 	r2 = *(u8 *)(r6 + 21)
      51:	b7 00 00 00 02 00 00 00 	r0 = 2
      52:	2d 20 5e 00 00 00 00 00 	if r0 > r2 goto +94 <LBB0_17>
; struct in6_addr *dst = (struct in6_addr *) fib_params.ipv6_dst;
      53:	bf a2 00 00 00 00 00 00 	r2 = r10
      54:	07 02 00 00 e0 ff ff ff 	r2 += -32
      55:	bf a3 00 00 00 00 00 00 	r3 = r10
      56:	07 03 00 00 d0 ff ff ff 	r3 += -48
; fib_params.family	= AF_INET6;
      57:	b7 04 00 00 0a 00 00 00 	r4 = 10
      58:	73 4a c0 ff 00 00 00 00 	*(u8 *)(r10 - 64) = r4
; fib_params.flowinfo	= *(__be32 *)ip6h & IPV6_FLOWINFO_MASK;
      59:	61 64 0e 00 00 00 00 00 	r4 = *(u32 *)(r6 + 14)
      60:	18 05 00 00 0f ff ff ff 00 00 00 00 00 00 00 00 	r5 = 4294967055 ll
      62:	5f 54 00 00 00 00 00 00 	r4 &= r5
      63:	63 4a cc ff 00 00 00 00 	*(u32 *)(r10 - 52) = r4
; fib_params.l4_protocol	= ip6h->nexthdr;
      64:	71 64 14 00 00 00 00 00 	r4 = *(u8 *)(r6 + 20)
      65:	73 4a c1 ff 00 00 00 00 	*(u8 *)(r10 - 63) = r4
      66:	b7 04 00 00 00 00 00 00 	r4 = 0
; fib_params.sport	= 0;
      67:	6b 4a c2 ff 00 00 00 00 	*(u16 *)(r10 - 62) = r4
; fib_params.dport	= 0;
      68:	6b 4a c4 ff 00 00 00 00 	*(u16 *)(r10 - 60) = r4
; fib_params.tot_len	= ntohs(ip6h->payload_len);
      69:	69 64 12 00 00 00 00 00 	r4 = *(u16 *)(r6 + 18)
      70:	dc 04 00 00 10 00 00 00 	r4 = be16 r4
      71:	6b 4a c6 ff 00 00 00 00 	*(u16 *)(r10 - 58) = r4
; *src			= ip6h->saddr;
      72:	61 64 22 00 00 00 00 00 	r4 = *(u32 *)(r6 + 34)
      73:	63 43 0c 00 00 00 00 00 	*(u32 *)(r3 + 12) = r4
      74:	61 64 1e 00 00 00 00 00 	r4 = *(u32 *)(r6 + 30)
      75:	63 43 08 00 00 00 00 00 	*(u32 *)(r3 + 8) = r4
      76:	61 64 1a 00 00 00 00 00 	r4 = *(u32 *)(r6 + 26)
      77:	63 43 04 00 00 00 00 00 	*(u32 *)(r3 + 4) = r4
      78:	61 64 16 00 00 00 00 00 	r4 = *(u32 *)(r6 + 22)
      79:	63 43 00 00 00 00 00 00 	*(u32 *)(r3 + 0) = r4
; *dst			= ip6h->daddr;
      80:	61 63 32 00 00 00 00 00 	r3 = *(u32 *)(r6 + 50)
      81:	63 32 0c 00 00 00 00 00 	*(u32 *)(r2 + 12) = r3
      82:	61 63 2e 00 00 00 00 00 	r3 = *(u32 *)(r6 + 46)
      83:	63 32 08 00 00 00 00 00 	*(u32 *)(r2 + 8) = r3
      84:	61 63 2a 00 00 00 00 00 	r3 = *(u32 *)(r6 + 42)
      85:	63 32 04 00 00 00 00 00 	*(u32 *)(r2 + 4) = r3
      86:	61 63 26 00 00 00 00 00 	r3 = *(u32 *)(r6 + 38)
      87:	63 32 00 00 00 00 00 00 	*(u32 *)(r2 + 0) = r3

LBB0_9:
; fib_params.ifindex = ctx->ingress_ifindex;
      88:	61 12 0c 00 00 00 00 00 	r2 = *(u32 *)(r1 + 12)
      89:	63 2a c8 ff 00 00 00 00 	*(u32 *)(r10 - 56) = r2
      90:	bf a2 00 00 00 00 00 00 	r2 = r10
      91:	07 02 00 00 c0 ff ff ff 	r2 += -64
; rc = bpf_fib_lookup(ctx, &fib_params, sizeof(fib_params), flags);
      92:	b7 03 00 00 40 00 00 00 	r3 = 64
      93:	b7 04 00 00 00 00 00 00 	r4 = 0
      94:	85 00 00 00 45 00 00 00 	call 69
      95:	bf 01 00 00 00 00 00 00 	r1 = r0
      96:	b7 00 00 00 02 00 00 00 	r0 = 2
      97:	67 01 00 00 20 00 00 00 	r1 <<= 32
      98:	77 01 00 00 20 00 00 00 	r1 >>= 32
; if (rc == 0) {
      99:	55 01 2f 00 00 00 00 00 	if r1 != 0 goto +47 <LBB0_17>
; if (h_proto == htons(ETH_P_IP))
     100:	55 08 0b 00 08 00 00 00 	if r8 != 8 goto +11 <LBB0_14>
; return --iph->ttl;
     101:	71 71 08 00 00 00 00 00 	r1 = *(u8 *)(r7 + 8)
     102:	07 01 00 00 ff ff ff ff 	r1 += -1
     103:	73 17 08 00 00 00 00 00 	*(u8 *)(r7 + 8) = r1
; u32 check = (__force u32)iph->check;
     104:	69 71 0a 00 00 00 00 00 	r1 = *(u16 *)(r7 + 10)
     105:	b7 02 00 00 01 00 00 00 	r2 = 1
; iph->check = (__force __sum16)(check + (check >= 0xFFFF));
     106:	25 01 01 00 fd ff 00 00 	if r1 > 65533 goto +1 <LBB0_13>
     107:	b7 02 00 00 00 00 00 00 	r2 = 0

LBB0_13:
; check += (__force u32)htons(0x0100);
     108:	0f 21 00 00 00 00 00 00 	r1 += r2
; iph->check = (__force __sum16)(check + (check >= 0xFFFF));
     109:	07 01 00 00 01 00 00 00 	r1 += 1
     110:	6b 17 0a 00 00 00 00 00 	*(u16 *)(r7 + 10) = r1
     111:	05 00 04 00 00 00 00 00 	goto +4 <LBB0_16>

LBB0_14:
; else if (h_proto == htons(ETH_P_IPV6))
     112:	55 08 03 00 86 dd 00 00 	if r8 != 56710 goto +3 <LBB0_16>
; ip6h->hop_limit--;
     113:	71 71 07 00 00 00 00 00 	r1 = *(u8 *)(r7 + 7)
     114:	07 01 00 00 ff ff ff ff 	r1 += -1
     115:	73 17 07 00 00 00 00 00 	*(u8 *)(r7 + 7) = r1

LBB0_16:
; memcpy(eth->h_dest, fib_params.dmac, ETH_ALEN);
     116:	69 a1 fe ff 00 00 00 00 	r1 = *(u16 *)(r10 - 2)
     117:	73 16 04 00 00 00 00 00 	*(u8 *)(r6 + 4) = r1
     118:	77 01 00 00 08 00 00 00 	r1 >>= 8
     119:	73 16 05 00 00 00 00 00 	*(u8 *)(r6 + 5) = r1
     120:	69 a1 fc ff 00 00 00 00 	r1 = *(u16 *)(r10 - 4)
     121:	73 16 02 00 00 00 00 00 	*(u8 *)(r6 + 2) = r1
     122:	77 01 00 00 08 00 00 00 	r1 >>= 8
     123:	73 16 03 00 00 00 00 00 	*(u8 *)(r6 + 3) = r1
     124:	69 a1 fa ff 00 00 00 00 	r1 = *(u16 *)(r10 - 6)
     125:	73 16 00 00 00 00 00 00 	*(u8 *)(r6 + 0) = r1
     126:	77 01 00 00 08 00 00 00 	r1 >>= 8
     127:	73 16 01 00 00 00 00 00 	*(u8 *)(r6 + 1) = r1
; memcpy(eth->h_source, fib_params.smac, ETH_ALEN);
     128:	69 a1 f8 ff 00 00 00 00 	r1 = *(u16 *)(r10 - 8)
     129:	73 16 0a 00 00 00 00 00 	*(u8 *)(r6 + 10) = r1
     130:	77 01 00 00 08 00 00 00 	r1 >>= 8
     131:	73 16 0b 00 00 00 00 00 	*(u8 *)(r6 + 11) = r1
     132:	61 a1 f4 ff 00 00 00 00 	r1 = *(u32 *)(r10 - 12)
     133:	bf 12 00 00 00 00 00 00 	r2 = r1
     134:	77 02 00 00 18 00 00 00 	r2 >>= 24
     135:	73 26 09 00 00 00 00 00 	*(u8 *)(r6 + 9) = r2
     136:	bf 12 00 00 00 00 00 00 	r2 = r1
     137:	77 02 00 00 10 00 00 00 	r2 >>= 16
     138:	73 26 08 00 00 00 00 00 	*(u8 *)(r6 + 8) = r2
     139:	73 16 06 00 00 00 00 00 	*(u8 *)(r6 + 6) = r1
     140:	77 01 00 00 08 00 00 00 	r1 >>= 8
     141:	73 16 07 00 00 00 00 00 	*(u8 *)(r6 + 7) = r1
; return bpf_redirect_map(&tx_port, fib_params.ifindex, 0);
     142:	61 a2 c8 ff 00 00 00 00 	r2 = *(u32 *)(r10 - 56)
     143:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 	r1 = 0 ll
     145:	b7 03 00 00 00 00 00 00 	r3 = 0
     146:	85 00 00 00 33 00 00 00 	call 51

LBB0_17:
; return xdp_fwd_flags(ctx, BPF_FIB_LOOKUP_DIRECT);
     147:	95 00 00 00 00 00 00 00 	exit
Disassembly of section xdp_fwd_direct:
xdp_fwd_direct_prog:
; {
       0:	b7 00 00 00 01 00 00 00 	r0 = 1
; void *data_end = (void *)(long)ctx->data_end;
       1:	61 12 04 00 00 00 00 00 	r2 = *(u32 *)(r1 + 4)
; void *data = (void *)(long)ctx->data;
       2:	61 16 00 00 00 00 00 00 	r6 = *(u32 *)(r1 + 0)
; if (data + nh_off > data_end)
       3:	bf 67 00 00 00 00 00 00 	r7 = r6
       4:	07 07 00 00 0e 00 00 00 	r7 += 14
       5:	2d 27 8d 00 00 00 00 00 	if r7 > r2 goto +141 <LBB1_17>
       6:	b7 03 00 00 00 00 00 00 	r3 = 0
; __builtin_memset(&fib_params, 0, sizeof(fib_params));
       7:	7b 3a f8 ff 00 00 00 00 	*(u64 *)(r10 - 8) = r3
       8:	7b 3a f0 ff 00 00 00 00 	*(u64 *)(r10 - 16) = r3
       9:	7b 3a e8 ff 00 00 00 00 	*(u64 *)(r10 - 24) = r3
      10:	7b 3a e0 ff 00 00 00 00 	*(u64 *)(r10 - 32) = r3
      11:	7b 3a d8 ff 00 00 00 00 	*(u64 *)(r10 - 40) = r3
      12:	7b 3a d0 ff 00 00 00 00 	*(u64 *)(r10 - 48) = r3
      13:	7b 3a c8 ff 00 00 00 00 	*(u64 *)(r10 - 56) = r3
      14:	7b 3a c0 ff 00 00 00 00 	*(u64 *)(r10 - 64) = r3
; h_proto = eth->h_proto;
      15:	71 63 0c 00 00 00 00 00 	r3 = *(u8 *)(r6 + 12)
      16:	71 68 0d 00 00 00 00 00 	r8 = *(u8 *)(r6 + 13)
      17:	67 08 00 00 08 00 00 00 	r8 <<= 8
      18:	4f 38 00 00 00 00 00 00 	r8 |= r3
; if (h_proto == htons(ETH_P_IP)) {
      19:	55 08 18 00 08 00 00 00 	if r8 != 8 goto +24 <LBB1_5>
; if (iph + 1 > data_end)
      20:	bf 63 00 00 00 00 00 00 	r3 = r6
      21:	07 03 00 00 22 00 00 00 	r3 += 34
      22:	b7 00 00 00 01 00 00 00 	r0 = 1
      23:	2d 23 7b 00 00 00 00 00 	if r3 > r2 goto +123 <LBB1_17>
; if (iph->ttl <= 1)
      24:	71 62 16 00 00 00 00 00 	r2 = *(u8 *)(r6 + 22)
      25:	b7 00 00 00 02 00 00 00 	r0 = 2
      26:	2d 20 78 00 00 00 00 00 	if r0 > r2 goto +120 <LBB1_17>
      27:	b7 02 00 00 02 00 00 00 	r2 = 2
; fib_params.family	= AF_INET;
      28:	73 2a c0 ff 00 00 00 00 	*(u8 *)(r10 - 64) = r2
; fib_params.tos		= iph->tos;
      29:	71 62 0f 00 00 00 00 00 	r2 = *(u8 *)(r6 + 15)
      30:	73 2a cc ff 00 00 00 00 	*(u8 *)(r10 - 52) = r2
; fib_params.l4_protocol	= iph->protocol;
      31:	71 62 17 00 00 00 00 00 	r2 = *(u8 *)(r6 + 23)
      32:	73 2a c1 ff 00 00 00 00 	*(u8 *)(r10 - 63) = r2
; fib_params.sport	= 0;
      33:	b7 02 00 00 00 00 00 00 	r2 = 0
      34:	6b 2a c2 ff 00 00 00 00 	*(u16 *)(r10 - 62) = r2
; fib_params.dport	= 0;
      35:	6b 2a c4 ff 00 00 00 00 	*(u16 *)(r10 - 60) = r2
; fib_params.tot_len	= ntohs(iph->tot_len);
      36:	69 62 10 00 00 00 00 00 	r2 = *(u16 *)(r6 + 16)
      37:	dc 02 00 00 10 00 00 00 	r2 = be16 r2
      38:	6b 2a c6 ff 00 00 00 00 	*(u16 *)(r10 - 58) = r2
; fib_params.ipv4_src	= iph->saddr;
      39:	61 62 1a 00 00 00 00 00 	r2 = *(u32 *)(r6 + 26)
      40:	63 2a d0 ff 00 00 00 00 	*(u32 *)(r10 - 48) = r2
; fib_params.ipv4_dst	= iph->daddr;
      41:	61 62 1e 00 00 00 00 00 	r2 = *(u32 *)(r6 + 30)
      42:	63 2a e0 ff 00 00 00 00 	*(u32 *)(r10 - 32) = r2
      43:	05 00 2c 00 00 00 00 00 	goto +44 <LBB1_9>

LBB1_5:
      44:	b7 00 00 00 02 00 00 00 	r0 = 2
; } else if (h_proto == htons(ETH_P_IPV6)) {
      45:	55 08 65 00 86 dd 00 00 	if r8 != 56710 goto +101 <LBB1_17>
; if (ip6h + 1 > data_end)
      46:	bf 63 00 00 00 00 00 00 	r3 = r6
      47:	07 03 00 00 36 00 00 00 	r3 += 54
      48:	b7 00 00 00 01 00 00 00 	r0 = 1
      49:	2d 23 61 00 00 00 00 00 	if r3 > r2 goto +97 <LBB1_17>
; if (ip6h->hop_limit <= 1)
      50:	71 62 15 00 00 00 00 00 	r2 = *(u8 *)(r6 + 21)
      51:	b7 00 00 00 02 00 00 00 	r0 = 2
      52:	2d 20 5e 00 00 00 00 00 	if r0 > r2 goto +94 <LBB1_17>
; struct in6_addr *dst = (struct in6_addr *) fib_params.ipv6_dst;
      53:	bf a2 00 00 00 00 00 00 	r2 = r10
      54:	07 02 00 00 e0 ff ff ff 	r2 += -32
      55:	bf a3 00 00 00 00 00 00 	r3 = r10
      56:	07 03 00 00 d0 ff ff ff 	r3 += -48
; fib_params.family	= AF_INET6;
      57:	b7 04 00 00 0a 00 00 00 	r4 = 10
      58:	73 4a c0 ff 00 00 00 00 	*(u8 *)(r10 - 64) = r4
; fib_params.flowinfo	= *(__be32 *)ip6h & IPV6_FLOWINFO_MASK;
      59:	61 64 0e 00 00 00 00 00 	r4 = *(u32 *)(r6 + 14)
      60:	18 05 00 00 0f ff ff ff 00 00 00 00 00 00 00 00 	r5 = 4294967055 ll
      62:	5f 54 00 00 00 00 00 00 	r4 &= r5
      63:	63 4a cc ff 00 00 00 00 	*(u32 *)(r10 - 52) = r4
; fib_params.l4_protocol	= ip6h->nexthdr;
      64:	71 64 14 00 00 00 00 00 	r4 = *(u8 *)(r6 + 20)
      65:	73 4a c1 ff 00 00 00 00 	*(u8 *)(r10 - 63) = r4
      66:	b7 04 00 00 00 00 00 00 	r4 = 0
; fib_params.sport	= 0;
      67:	6b 4a c2 ff 00 00 00 00 	*(u16 *)(r10 - 62) = r4
; fib_params.dport	= 0;
      68:	6b 4a c4 ff 00 00 00 00 	*(u16 *)(r10 - 60) = r4
; fib_params.tot_len	= ntohs(ip6h->payload_len);
      69:	69 64 12 00 00 00 00 00 	r4 = *(u16 *)(r6 + 18)
      70:	dc 04 00 00 10 00 00 00 	r4 = be16 r4
      71:	6b 4a c6 ff 00 00 00 00 	*(u16 *)(r10 - 58) = r4
; *src			= ip6h->saddr;
      72:	61 64 22 00 00 00 00 00 	r4 = *(u32 *)(r6 + 34)
      73:	63 43 0c 00 00 00 00 00 	*(u32 *)(r3 + 12) = r4
      74:	61 64 1e 00 00 00 00 00 	r4 = *(u32 *)(r6 + 30)
      75:	63 43 08 00 00 00 00 00 	*(u32 *)(r3 + 8) = r4
      76:	61 64 1a 00 00 00 00 00 	r4 = *(u32 *)(r6 + 26)
      77:	63 43 04 00 00 00 00 00 	*(u32 *)(r3 + 4) = r4
      78:	61 64 16 00 00 00 00 00 	r4 = *(u32 *)(r6 + 22)
      79:	63 43 00 00 00 00 00 00 	*(u32 *)(r3 + 0) = r4
; *dst			= ip6h->daddr;
      80:	61 63 32 00 00 00 00 00 	r3 = *(u32 *)(r6 + 50)
      81:	63 32 0c 00 00 00 00 00 	*(u32 *)(r2 + 12) = r3
      82:	61 63 2e 00 00 00 00 00 	r3 = *(u32 *)(r6 + 46)
      83:	63 32 08 00 00 00 00 00 	*(u32 *)(r2 + 8) = r3
      84:	61 63 2a 00 00 00 00 00 	r3 = *(u32 *)(r6 + 42)
      85:	63 32 04 00 00 00 00 00 	*(u32 *)(r2 + 4) = r3
      86:	61 63 26 00 00 00 00 00 	r3 = *(u32 *)(r6 + 38)
      87:	63 32 00 00 00 00 00 00 	*(u32 *)(r2 + 0) = r3

LBB1_9:
; fib_params.ifindex = ctx->ingress_ifindex;
      88:	61 12 0c 00 00 00 00 00 	r2 = *(u32 *)(r1 + 12)
      89:	63 2a c8 ff 00 00 00 00 	*(u32 *)(r10 - 56) = r2
      90:	bf a2 00 00 00 00 00 00 	r2 = r10
      91:	07 02 00 00 c0 ff ff ff 	r2 += -64
; rc = bpf_fib_lookup(ctx, &fib_params, sizeof(fib_params), flags);
      92:	b7 03 00 00 40 00 00 00 	r3 = 64
      93:	b7 04 00 00 01 00 00 00 	r4 = 1
      94:	85 00 00 00 45 00 00 00 	call 69
      95:	bf 01 00 00 00 00 00 00 	r1 = r0
      96:	b7 00 00 00 02 00 00 00 	r0 = 2
      97:	67 01 00 00 20 00 00 00 	r1 <<= 32
      98:	77 01 00 00 20 00 00 00 	r1 >>= 32
; if (rc == 0) {
      99:	55 01 2f 00 00 00 00 00 	if r1 != 0 goto +47 <LBB1_17>
; if (h_proto == htons(ETH_P_IP))
     100:	55 08 0b 00 08 00 00 00 	if r8 != 8 goto +11 <LBB1_14>
; return --iph->ttl;
     101:	71 71 08 00 00 00 00 00 	r1 = *(u8 *)(r7 + 8)
     102:	07 01 00 00 ff ff ff ff 	r1 += -1
     103:	73 17 08 00 00 00 00 00 	*(u8 *)(r7 + 8) = r1
; u32 check = (__force u32)iph->check;
     104:	69 71 0a 00 00 00 00 00 	r1 = *(u16 *)(r7 + 10)
     105:	b7 02 00 00 01 00 00 00 	r2 = 1
; iph->check = (__force __sum16)(check + (check >= 0xFFFF));
     106:	25 01 01 00 fd ff 00 00 	if r1 > 65533 goto +1 <LBB1_13>
     107:	b7 02 00 00 00 00 00 00 	r2 = 0

LBB1_13:
; check += (__force u32)htons(0x0100);
     108:	0f 21 00 00 00 00 00 00 	r1 += r2
; iph->check = (__force __sum16)(check + (check >= 0xFFFF));
     109:	07 01 00 00 01 00 00 00 	r1 += 1
     110:	6b 17 0a 00 00 00 00 00 	*(u16 *)(r7 + 10) = r1
     111:	05 00 04 00 00 00 00 00 	goto +4 <LBB1_16>

LBB1_14:
; else if (h_proto == htons(ETH_P_IPV6))
     112:	55 08 03 00 86 dd 00 00 	if r8 != 56710 goto +3 <LBB1_16>
; ip6h->hop_limit--;
     113:	71 71 07 00 00 00 00 00 	r1 = *(u8 *)(r7 + 7)
     114:	07 01 00 00 ff ff ff ff 	r1 += -1
     115:	73 17 07 00 00 00 00 00 	*(u8 *)(r7 + 7) = r1

LBB1_16:
; memcpy(eth->h_dest, fib_params.dmac, ETH_ALEN);
     116:	69 a1 fe ff 00 00 00 00 	r1 = *(u16 *)(r10 - 2)
     117:	73 16 04 00 00 00 00 00 	*(u8 *)(r6 + 4) = r1
     118:	77 01 00 00 08 00 00 00 	r1 >>= 8
     119:	73 16 05 00 00 00 00 00 	*(u8 *)(r6 + 5) = r1
     120:	69 a1 fc ff 00 00 00 00 	r1 = *(u16 *)(r10 - 4)
     121:	73 16 02 00 00 00 00 00 	*(u8 *)(r6 + 2) = r1
     122:	77 01 00 00 08 00 00 00 	r1 >>= 8
     123:	73 16 03 00 00 00 00 00 	*(u8 *)(r6 + 3) = r1
     124:	69 a1 fa ff 00 00 00 00 	r1 = *(u16 *)(r10 - 6)
     125:	73 16 00 00 00 00 00 00 	*(u8 *)(r6 + 0) = r1
     126:	77 01 00 00 08 00 00 00 	r1 >>= 8
     127:	73 16 01 00 00 00 00 00 	*(u8 *)(r6 + 1) = r1
; memcpy(eth->h_source, fib_params.smac, ETH_ALEN);
     128:	69 a1 f8 ff 00 00 00 00 	r1 = *(u16 *)(r10 - 8)
     129:	73 16 0a 00 00 00 00 00 	*(u8 *)(r6 + 10) = r1
     130:	77 01 00 00 08 00 00 00 	r1 >>= 8
     131:	73 16 0b 00 00 00 00 00 	*(u8 *)(r6 + 11) = r1
     132:	61 a1 f4 ff 00 00 00 00 	r1 = *(u32 *)(r10 - 12)
     133:	bf 12 00 00 00 00 00 00 	r2 = r1
     134:	77 02 00 00 18 00 00 00 	r2 >>= 24
     135:	73 26 09 00 00 00 00 00 	*(u8 *)(r6 + 9) = r2
     136:	bf 12 00 00 00 00 00 00 	r2 = r1
     137:	77 02 00 00 10 00 00 00 	r2 >>= 16
     138:	73 26 08 00 00 00 00 00 	*(u8 *)(r6 + 8) = r2
     139:	73 16 06 00 00 00 00 00 	*(u8 *)(r6 + 6) = r1
     140:	77 01 00 00 08 00 00 00 	r1 >>= 8
     141:	73 16 07 00 00 00 00 00 	*(u8 *)(r6 + 7) = r1
; return bpf_redirect_map(&tx_port, fib_params.ifindex, 0);
     142:	61 a2 c8 ff 00 00 00 00 	r2 = *(u32 *)(r10 - 56)
     143:	18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 	r1 = 0 ll
     145:	b7 03 00 00 00 00 00 00 	r3 = 0
     146:	85 00 00 00 33 00 00 00 	call 51

LBB1_17:
; return xdp_fwd_flags(ctx, BPF_FIB_LOOKUP_DIRECT);
     147:	95 00 00 00 00 00 00 00 	exit
